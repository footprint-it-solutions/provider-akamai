// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ApplicationLoadBalancerInitParameters struct {

	// The type of load balancing being performed. Options include WEIGHTED and PERFORMANCE
	BalancingType *string `json:"balancingType,omitempty" tf:"balancing_type,omitempty"`

	// The object containing information on conditional origins being used as data centers for an Application Load Balancer implementation. Only Conditional Origins with an originType of CUSTOMER or NETSTORAGE can be used as data centers in an application load balancer configuration.
	DataCenters []DataCentersInitParameters `json:"dataCenters,omitempty" tf:"data_centers,omitempty"`

	// The load balancer configuration version description
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	LivenessSettings []LivenessSettingsInitParameters `json:"livenessSettings,omitempty" tf:"liveness_settings,omitempty"`

	// The load balancer configuration description
	OriginDescription *string `json:"originDescription,omitempty" tf:"origin_description,omitempty"`

	// The conditional origin's unique identifier
	OriginID *string `json:"originId,omitempty" tf:"origin_id,omitempty"`
}

type ApplicationLoadBalancerObservation struct {

	// The type of load balancing being performed. Options include WEIGHTED and PERFORMANCE
	BalancingType *string `json:"balancingType,omitempty" tf:"balancing_type,omitempty"`

	// The object containing information on conditional origins being used as data centers for an Application Load Balancer implementation. Only Conditional Origins with an originType of CUSTOMER or NETSTORAGE can be used as data centers in an application load balancer configuration.
	DataCenters []DataCentersObservation `json:"dataCenters,omitempty" tf:"data_centers,omitempty"`

	// The load balancer configuration version description
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	LivenessSettings []LivenessSettingsObservation `json:"livenessSettings,omitempty" tf:"liveness_settings,omitempty"`

	// The load balancer configuration description
	OriginDescription *string `json:"originDescription,omitempty" tf:"origin_description,omitempty"`

	// The conditional origin's unique identifier
	OriginID *string `json:"originId,omitempty" tf:"origin_id,omitempty"`

	// The load balancer configuration version
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`

	// Describes warnings during activation of load balancer configuration
	Warnings *string `json:"warnings,omitempty" tf:"warnings,omitempty"`
}

type ApplicationLoadBalancerParameters struct {

	// The type of load balancing being performed. Options include WEIGHTED and PERFORMANCE
	// +kubebuilder:validation:Optional
	BalancingType *string `json:"balancingType,omitempty" tf:"balancing_type,omitempty"`

	// The object containing information on conditional origins being used as data centers for an Application Load Balancer implementation. Only Conditional Origins with an originType of CUSTOMER or NETSTORAGE can be used as data centers in an application load balancer configuration.
	// +kubebuilder:validation:Optional
	DataCenters []DataCentersParameters `json:"dataCenters,omitempty" tf:"data_centers,omitempty"`

	// The load balancer configuration version description
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	LivenessSettings []LivenessSettingsParameters `json:"livenessSettings,omitempty" tf:"liveness_settings,omitempty"`

	// The load balancer configuration description
	// +kubebuilder:validation:Optional
	OriginDescription *string `json:"originDescription,omitempty" tf:"origin_description,omitempty"`

	// The conditional origin's unique identifier
	// +kubebuilder:validation:Optional
	OriginID *string `json:"originId,omitempty" tf:"origin_id,omitempty"`
}

type DataCentersInitParameters struct {

	// The city in which the data center is located.
	City *string `json:"city,omitempty" tf:"city,omitempty"`

	// Describes if cloud server host header is overridden
	CloudServerHostHeaderOverride *bool `json:"cloudServerHostHeaderOverride,omitempty" tf:"cloud_server_host_header_override,omitempty"`

	// Describes if this datacenter is a cloud service
	CloudService *bool `json:"cloudService,omitempty" tf:"cloud_service,omitempty"`

	// The continent on which the data center is located
	Continent *string `json:"continent,omitempty" tf:"continent,omitempty"`

	// The country in which the data center is located
	Country *string `json:"country,omitempty" tf:"country,omitempty"`

	// This should match the 'hostname' value defined for this datacenter in Property Manager
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// The latitude value for the data center. This member supports six decimal places of precision.
	Latitude *float64 `json:"latitude,omitempty" tf:"latitude,omitempty"`

	// An array of strings that represent the origin servers used to poll the data centers in an application load balancer configuration. These servers support basic HTTP polling.
	LivenessHosts []*string `json:"livenessHosts,omitempty" tf:"liveness_hosts,omitempty"`

	// The longitude value for the data center. This member supports six decimal places of precision.
	Longitude *float64 `json:"longitude,omitempty" tf:"longitude,omitempty"`

	// The ID of an origin that represents the data center. The conditional origin, which is defined in the Property Manager API, must have an originType of either CUSTOMER or NET_STORAGE
	OriginID *string `json:"originId,omitempty" tf:"origin_id,omitempty"`

	// The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
	Percent *float64 `json:"percent,omitempty" tf:"percent,omitempty"`

	// The state, province, or region where the data center is located
	StateOrProvince *string `json:"stateOrProvince,omitempty" tf:"state_or_province,omitempty"`
}

type DataCentersObservation struct {

	// The city in which the data center is located.
	City *string `json:"city,omitempty" tf:"city,omitempty"`

	// Describes if cloud server host header is overridden
	CloudServerHostHeaderOverride *bool `json:"cloudServerHostHeaderOverride,omitempty" tf:"cloud_server_host_header_override,omitempty"`

	// Describes if this datacenter is a cloud service
	CloudService *bool `json:"cloudService,omitempty" tf:"cloud_service,omitempty"`

	// The continent on which the data center is located
	Continent *string `json:"continent,omitempty" tf:"continent,omitempty"`

	// The country in which the data center is located
	Country *string `json:"country,omitempty" tf:"country,omitempty"`

	// This should match the 'hostname' value defined for this datacenter in Property Manager
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// The latitude value for the data center. This member supports six decimal places of precision.
	Latitude *float64 `json:"latitude,omitempty" tf:"latitude,omitempty"`

	// An array of strings that represent the origin servers used to poll the data centers in an application load balancer configuration. These servers support basic HTTP polling.
	LivenessHosts []*string `json:"livenessHosts,omitempty" tf:"liveness_hosts,omitempty"`

	// The longitude value for the data center. This member supports six decimal places of precision.
	Longitude *float64 `json:"longitude,omitempty" tf:"longitude,omitempty"`

	// The ID of an origin that represents the data center. The conditional origin, which is defined in the Property Manager API, must have an originType of either CUSTOMER or NET_STORAGE
	OriginID *string `json:"originId,omitempty" tf:"origin_id,omitempty"`

	// The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
	Percent *float64 `json:"percent,omitempty" tf:"percent,omitempty"`

	// The state, province, or region where the data center is located
	StateOrProvince *string `json:"stateOrProvince,omitempty" tf:"state_or_province,omitempty"`
}

type DataCentersParameters struct {

	// The city in which the data center is located.
	// +kubebuilder:validation:Optional
	City *string `json:"city,omitempty" tf:"city,omitempty"`

	// Describes if cloud server host header is overridden
	// +kubebuilder:validation:Optional
	CloudServerHostHeaderOverride *bool `json:"cloudServerHostHeaderOverride,omitempty" tf:"cloud_server_host_header_override,omitempty"`

	// Describes if this datacenter is a cloud service
	// +kubebuilder:validation:Optional
	CloudService *bool `json:"cloudService,omitempty" tf:"cloud_service,omitempty"`

	// The continent on which the data center is located
	// +kubebuilder:validation:Optional
	Continent *string `json:"continent" tf:"continent,omitempty"`

	// The country in which the data center is located
	// +kubebuilder:validation:Optional
	Country *string `json:"country" tf:"country,omitempty"`

	// This should match the 'hostname' value defined for this datacenter in Property Manager
	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// The latitude value for the data center. This member supports six decimal places of precision.
	// +kubebuilder:validation:Optional
	Latitude *float64 `json:"latitude" tf:"latitude,omitempty"`

	// An array of strings that represent the origin servers used to poll the data centers in an application load balancer configuration. These servers support basic HTTP polling.
	// +kubebuilder:validation:Optional
	LivenessHosts []*string `json:"livenessHosts,omitempty" tf:"liveness_hosts,omitempty"`

	// The longitude value for the data center. This member supports six decimal places of precision.
	// +kubebuilder:validation:Optional
	Longitude *float64 `json:"longitude" tf:"longitude,omitempty"`

	// The ID of an origin that represents the data center. The conditional origin, which is defined in the Property Manager API, must have an originType of either CUSTOMER or NET_STORAGE
	// +kubebuilder:validation:Optional
	OriginID *string `json:"originId" tf:"origin_id,omitempty"`

	// The percent of traffic that is sent to the data center. The total for all data centers must equal 100%.
	// +kubebuilder:validation:Optional
	Percent *float64 `json:"percent" tf:"percent,omitempty"`

	// The state, province, or region where the data center is located
	// +kubebuilder:validation:Optional
	StateOrProvince *string `json:"stateOrProvince,omitempty" tf:"state_or_province,omitempty"`
}

type LivenessSettingsInitParameters struct {

	// Maps additional case-insensitive HTTP header names included to the liveness testing requests
	// +mapType=granular
	AdditionalHeaders map[string]*string `json:"additionalHeaders,omitempty" tf:"additional_headers,omitempty"`

	// The Host header for the liveness HTTP request
	HostHeader *string `json:"hostHeader,omitempty" tf:"host_header,omitempty"`

	// Describes how often the liveness test will be performed. Optional defaults to 60 seconds, minimum is 10 seconds.
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Describes whether or not to validate the origin certificate for an HTTPS request
	PeerCertificateVerification *bool `json:"peerCertificateVerification,omitempty" tf:"peer_certificate_verification,omitempty"`

	// The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// The protocol or scheme for the database, either HTTP or HTTPS.
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// The request which will be used for TCP(S) tests
	RequestString *string `json:"requestString,omitempty" tf:"request_string,omitempty"`

	ResponseString *string `json:"responseString,omitempty" tf:"response_string,omitempty"`

	// Set to true to mark the liveness test as failed when the request returns a 3xx (redirection) status code.
	Status3XxFailure *bool `json:"status3XxFailure,omitempty" tf:"status_3xx_failure,omitempty"`

	// Set to true to mark the liveness test as failed when the request returns a 4xx (client error) status code.
	Status4XxFailure *bool `json:"status4XxFailure,omitempty" tf:"status_4xx_failure,omitempty"`

	// Set to true to mark the liveness test as failed when the request returns a 5xx (server error) status code.
	Status5XxFailure *bool `json:"status5XxFailure,omitempty" tf:"status_5xx_failure,omitempty"`

	// The number of seconds the system waits before failing the liveness test. The default is 25 seconds.
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type LivenessSettingsObservation struct {

	// Maps additional case-insensitive HTTP header names included to the liveness testing requests
	// +mapType=granular
	AdditionalHeaders map[string]*string `json:"additionalHeaders,omitempty" tf:"additional_headers,omitempty"`

	// The Host header for the liveness HTTP request
	HostHeader *string `json:"hostHeader,omitempty" tf:"host_header,omitempty"`

	// Describes how often the liveness test will be performed. Optional defaults to 60 seconds, minimum is 10 seconds.
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Describes whether or not to validate the origin certificate for an HTTPS request
	PeerCertificateVerification *bool `json:"peerCertificateVerification,omitempty" tf:"peer_certificate_verification,omitempty"`

	// The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// The protocol or scheme for the database, either HTTP or HTTPS.
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// The request which will be used for TCP(S) tests
	RequestString *string `json:"requestString,omitempty" tf:"request_string,omitempty"`

	ResponseString *string `json:"responseString,omitempty" tf:"response_string,omitempty"`

	// Set to true to mark the liveness test as failed when the request returns a 3xx (redirection) status code.
	Status3XxFailure *bool `json:"status3XxFailure,omitempty" tf:"status_3xx_failure,omitempty"`

	// Set to true to mark the liveness test as failed when the request returns a 4xx (client error) status code.
	Status4XxFailure *bool `json:"status4XxFailure,omitempty" tf:"status_4xx_failure,omitempty"`

	// Set to true to mark the liveness test as failed when the request returns a 5xx (server error) status code.
	Status5XxFailure *bool `json:"status5XxFailure,omitempty" tf:"status_5xx_failure,omitempty"`

	// The number of seconds the system waits before failing the liveness test. The default is 25 seconds.
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type LivenessSettingsParameters struct {

	// Maps additional case-insensitive HTTP header names included to the liveness testing requests
	// +kubebuilder:validation:Optional
	// +mapType=granular
	AdditionalHeaders map[string]*string `json:"additionalHeaders,omitempty" tf:"additional_headers,omitempty"`

	// The Host header for the liveness HTTP request
	// +kubebuilder:validation:Optional
	HostHeader *string `json:"hostHeader,omitempty" tf:"host_header,omitempty"`

	// Describes how often the liveness test will be performed. Optional defaults to 60 seconds, minimum is 10 seconds.
	// +kubebuilder:validation:Optional
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// The path to the test object used for liveness testing. The function of the test object is to help determine whether the data center is functioning.
	// +kubebuilder:validation:Optional
	Path *string `json:"path" tf:"path,omitempty"`

	// Describes whether or not to validate the origin certificate for an HTTPS request
	// +kubebuilder:validation:Optional
	PeerCertificateVerification *bool `json:"peerCertificateVerification,omitempty" tf:"peer_certificate_verification,omitempty"`

	// The port for the test object. The default port is 80, which is standard for HTTP. Enter 443 if you are using HTTPS.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port" tf:"port,omitempty"`

	// The protocol or scheme for the database, either HTTP or HTTPS.
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// The request which will be used for TCP(S) tests
	// +kubebuilder:validation:Optional
	RequestString *string `json:"requestString,omitempty" tf:"request_string,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseString *string `json:"responseString,omitempty" tf:"response_string,omitempty"`

	// Set to true to mark the liveness test as failed when the request returns a 3xx (redirection) status code.
	// +kubebuilder:validation:Optional
	Status3XxFailure *bool `json:"status3XxFailure,omitempty" tf:"status_3xx_failure,omitempty"`

	// Set to true to mark the liveness test as failed when the request returns a 4xx (client error) status code.
	// +kubebuilder:validation:Optional
	Status4XxFailure *bool `json:"status4XxFailure,omitempty" tf:"status_4xx_failure,omitempty"`

	// Set to true to mark the liveness test as failed when the request returns a 5xx (server error) status code.
	// +kubebuilder:validation:Optional
	Status5XxFailure *bool `json:"status5XxFailure,omitempty" tf:"status_5xx_failure,omitempty"`

	// The number of seconds the system waits before failing the liveness test. The default is 25 seconds.
	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

// ApplicationLoadBalancerSpec defines the desired state of ApplicationLoadBalancer
type ApplicationLoadBalancerSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ApplicationLoadBalancerParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ApplicationLoadBalancerInitParameters `json:"initProvider,omitempty"`
}

// ApplicationLoadBalancerStatus defines the observed state of ApplicationLoadBalancer.
type ApplicationLoadBalancerStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ApplicationLoadBalancerObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// ApplicationLoadBalancer is the Schema for the ApplicationLoadBalancers API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,akamai}
type ApplicationLoadBalancer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.dataCenters) || (has(self.initProvider) && has(self.initProvider.dataCenters))",message="spec.forProvider.dataCenters is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.originId) || (has(self.initProvider) && has(self.initProvider.originId))",message="spec.forProvider.originId is a required parameter"
	Spec   ApplicationLoadBalancerSpec   `json:"spec"`
	Status ApplicationLoadBalancerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ApplicationLoadBalancerList contains a list of ApplicationLoadBalancers
type ApplicationLoadBalancerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ApplicationLoadBalancer `json:"items"`
}

// Repository type metadata.
var (
	ApplicationLoadBalancer_Kind             = "ApplicationLoadBalancer"
	ApplicationLoadBalancer_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ApplicationLoadBalancer_Kind}.String()
	ApplicationLoadBalancer_KindAPIVersion   = ApplicationLoadBalancer_Kind + "." + CRDGroupVersion.String()
	ApplicationLoadBalancer_GroupVersionKind = CRDGroupVersion.WithKind(ApplicationLoadBalancer_Kind)
)

func init() {
	SchemeBuilder.Register(&ApplicationLoadBalancer{}, &ApplicationLoadBalancerList{})
}
