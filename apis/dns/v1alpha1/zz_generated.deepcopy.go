//go:build !ignore_autogenerated

// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OutboundZoneTransferInitParameters) DeepCopyInto(out *OutboundZoneTransferInitParameters) {
	*out = *in
	if in.ACL != nil {
		in, out := &in.ACL, &out.ACL
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.NotifyTargets != nil {
		in, out := &in.NotifyTargets, &out.NotifyTargets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TsigKey != nil {
		in, out := &in.TsigKey, &out.TsigKey
		*out = make([]TsigKeyInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OutboundZoneTransferInitParameters.
func (in *OutboundZoneTransferInitParameters) DeepCopy() *OutboundZoneTransferInitParameters {
	if in == nil {
		return nil
	}
	out := new(OutboundZoneTransferInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OutboundZoneTransferObservation) DeepCopyInto(out *OutboundZoneTransferObservation) {
	*out = *in
	if in.ACL != nil {
		in, out := &in.ACL, &out.ACL
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.NotifyTargets != nil {
		in, out := &in.NotifyTargets, &out.NotifyTargets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TsigKey != nil {
		in, out := &in.TsigKey, &out.TsigKey
		*out = make([]TsigKeyObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OutboundZoneTransferObservation.
func (in *OutboundZoneTransferObservation) DeepCopy() *OutboundZoneTransferObservation {
	if in == nil {
		return nil
	}
	out := new(OutboundZoneTransferObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OutboundZoneTransferParameters) DeepCopyInto(out *OutboundZoneTransferParameters) {
	*out = *in
	if in.ACL != nil {
		in, out := &in.ACL, &out.ACL
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.NotifyTargets != nil {
		in, out := &in.NotifyTargets, &out.NotifyTargets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TsigKey != nil {
		in, out := &in.TsigKey, &out.TsigKey
		*out = make([]TsigKeyParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OutboundZoneTransferParameters.
func (in *OutboundZoneTransferParameters) DeepCopy() *OutboundZoneTransferParameters {
	if in == nil {
		return nil
	}
	out := new(OutboundZoneTransferParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Record) DeepCopyInto(out *Record) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Record.
func (in *Record) DeepCopy() *Record {
	if in == nil {
		return nil
	}
	out := new(Record)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Record) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RecordInitParameters) DeepCopyInto(out *RecordInitParameters) {
	*out = *in
	if in.Algorithm != nil {
		in, out := &in.Algorithm, &out.Algorithm
		*out = new(float64)
		**out = **in
	}
	if in.Certificate != nil {
		in, out := &in.Certificate, &out.Certificate
		*out = new(string)
		**out = **in
	}
	if in.Digest != nil {
		in, out := &in.Digest, &out.Digest
		*out = new(string)
		**out = **in
	}
	if in.DigestType != nil {
		in, out := &in.DigestType, &out.DigestType
		*out = new(float64)
		**out = **in
	}
	if in.EmailAddress != nil {
		in, out := &in.EmailAddress, &out.EmailAddress
		*out = new(string)
		**out = **in
	}
	if in.Expiration != nil {
		in, out := &in.Expiration, &out.Expiration
		*out = new(string)
		**out = **in
	}
	if in.Expiry != nil {
		in, out := &in.Expiry, &out.Expiry
		*out = new(float64)
		**out = **in
	}
	if in.Fingerprint != nil {
		in, out := &in.Fingerprint, &out.Fingerprint
		*out = new(string)
		**out = **in
	}
	if in.FingerprintType != nil {
		in, out := &in.FingerprintType, &out.FingerprintType
		*out = new(float64)
		**out = **in
	}
	if in.Flags != nil {
		in, out := &in.Flags, &out.Flags
		*out = new(float64)
		**out = **in
	}
	if in.Flagsnaptr != nil {
		in, out := &in.Flagsnaptr, &out.Flagsnaptr
		*out = new(string)
		**out = **in
	}
	if in.Hardware != nil {
		in, out := &in.Hardware, &out.Hardware
		*out = new(string)
		**out = **in
	}
	if in.Inception != nil {
		in, out := &in.Inception, &out.Inception
		*out = new(string)
		**out = **in
	}
	if in.Iterations != nil {
		in, out := &in.Iterations, &out.Iterations
		*out = new(float64)
		**out = **in
	}
	if in.Key != nil {
		in, out := &in.Key, &out.Key
		*out = new(string)
		**out = **in
	}
	if in.Keytag != nil {
		in, out := &in.Keytag, &out.Keytag
		*out = new(float64)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = new(float64)
		**out = **in
	}
	if in.Mailbox != nil {
		in, out := &in.Mailbox, &out.Mailbox
		*out = new(string)
		**out = **in
	}
	if in.MatchType != nil {
		in, out := &in.MatchType, &out.MatchType
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NameServer != nil {
		in, out := &in.NameServer, &out.NameServer
		*out = new(string)
		**out = **in
	}
	if in.NextHashedOwnerName != nil {
		in, out := &in.NextHashedOwnerName, &out.NextHashedOwnerName
		*out = new(string)
		**out = **in
	}
	if in.NxdomainTTL != nil {
		in, out := &in.NxdomainTTL, &out.NxdomainTTL
		*out = new(float64)
		**out = **in
	}
	if in.Order != nil {
		in, out := &in.Order, &out.Order
		*out = new(float64)
		**out = **in
	}
	if in.OriginalTTL != nil {
		in, out := &in.OriginalTTL, &out.OriginalTTL
		*out = new(float64)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.Preference != nil {
		in, out := &in.Preference, &out.Preference
		*out = new(float64)
		**out = **in
	}
	if in.Priority != nil {
		in, out := &in.Priority, &out.Priority
		*out = new(float64)
		**out = **in
	}
	if in.PriorityIncrement != nil {
		in, out := &in.PriorityIncrement, &out.PriorityIncrement
		*out = new(float64)
		**out = **in
	}
	if in.Protocol != nil {
		in, out := &in.Protocol, &out.Protocol
		*out = new(float64)
		**out = **in
	}
	if in.Recordtype != nil {
		in, out := &in.Recordtype, &out.Recordtype
		*out = new(string)
		**out = **in
	}
	if in.Refresh != nil {
		in, out := &in.Refresh, &out.Refresh
		*out = new(float64)
		**out = **in
	}
	if in.Regexp != nil {
		in, out := &in.Regexp, &out.Regexp
		*out = new(string)
		**out = **in
	}
	if in.Replacement != nil {
		in, out := &in.Replacement, &out.Replacement
		*out = new(string)
		**out = **in
	}
	if in.Retry != nil {
		in, out := &in.Retry, &out.Retry
		*out = new(float64)
		**out = **in
	}
	if in.Salt != nil {
		in, out := &in.Salt, &out.Salt
		*out = new(string)
		**out = **in
	}
	if in.Selector != nil {
		in, out := &in.Selector, &out.Selector
		*out = new(float64)
		**out = **in
	}
	if in.Service != nil {
		in, out := &in.Service, &out.Service
		*out = new(string)
		**out = **in
	}
	if in.Signature != nil {
		in, out := &in.Signature, &out.Signature
		*out = new(string)
		**out = **in
	}
	if in.Signer != nil {
		in, out := &in.Signer, &out.Signer
		*out = new(string)
		**out = **in
	}
	if in.Software != nil {
		in, out := &in.Software, &out.Software
		*out = new(string)
		**out = **in
	}
	if in.Subtype != nil {
		in, out := &in.Subtype, &out.Subtype
		*out = new(float64)
		**out = **in
	}
	if in.SvcParams != nil {
		in, out := &in.SvcParams, &out.SvcParams
		*out = new(string)
		**out = **in
	}
	if in.SvcPriority != nil {
		in, out := &in.SvcPriority, &out.SvcPriority
		*out = new(float64)
		**out = **in
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(float64)
		**out = **in
	}
	if in.Target != nil {
		in, out := &in.Target, &out.Target
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TargetName != nil {
		in, out := &in.TargetName, &out.TargetName
		*out = new(string)
		**out = **in
	}
	if in.Txt != nil {
		in, out := &in.Txt, &out.Txt
		*out = new(string)
		**out = **in
	}
	if in.TypeBitmaps != nil {
		in, out := &in.TypeBitmaps, &out.TypeBitmaps
		*out = new(string)
		**out = **in
	}
	if in.TypeCovered != nil {
		in, out := &in.TypeCovered, &out.TypeCovered
		*out = new(string)
		**out = **in
	}
	if in.TypeMnemonic != nil {
		in, out := &in.TypeMnemonic, &out.TypeMnemonic
		*out = new(string)
		**out = **in
	}
	if in.TypeValue != nil {
		in, out := &in.TypeValue, &out.TypeValue
		*out = new(float64)
		**out = **in
	}
	if in.Usage != nil {
		in, out := &in.Usage, &out.Usage
		*out = new(float64)
		**out = **in
	}
	if in.Weight != nil {
		in, out := &in.Weight, &out.Weight
		*out = new(float64)
		**out = **in
	}
	if in.Zone != nil {
		in, out := &in.Zone, &out.Zone
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RecordInitParameters.
func (in *RecordInitParameters) DeepCopy() *RecordInitParameters {
	if in == nil {
		return nil
	}
	out := new(RecordInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RecordList) DeepCopyInto(out *RecordList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Record, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RecordList.
func (in *RecordList) DeepCopy() *RecordList {
	if in == nil {
		return nil
	}
	out := new(RecordList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RecordList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RecordObservation) DeepCopyInto(out *RecordObservation) {
	*out = *in
	if in.Algorithm != nil {
		in, out := &in.Algorithm, &out.Algorithm
		*out = new(float64)
		**out = **in
	}
	if in.AnswerType != nil {
		in, out := &in.AnswerType, &out.AnswerType
		*out = new(string)
		**out = **in
	}
	if in.Certificate != nil {
		in, out := &in.Certificate, &out.Certificate
		*out = new(string)
		**out = **in
	}
	if in.DNSName != nil {
		in, out := &in.DNSName, &out.DNSName
		*out = new(string)
		**out = **in
	}
	if in.Digest != nil {
		in, out := &in.Digest, &out.Digest
		*out = new(string)
		**out = **in
	}
	if in.DigestType != nil {
		in, out := &in.DigestType, &out.DigestType
		*out = new(float64)
		**out = **in
	}
	if in.EmailAddress != nil {
		in, out := &in.EmailAddress, &out.EmailAddress
		*out = new(string)
		**out = **in
	}
	if in.Expiration != nil {
		in, out := &in.Expiration, &out.Expiration
		*out = new(string)
		**out = **in
	}
	if in.Expiry != nil {
		in, out := &in.Expiry, &out.Expiry
		*out = new(float64)
		**out = **in
	}
	if in.Fingerprint != nil {
		in, out := &in.Fingerprint, &out.Fingerprint
		*out = new(string)
		**out = **in
	}
	if in.FingerprintType != nil {
		in, out := &in.FingerprintType, &out.FingerprintType
		*out = new(float64)
		**out = **in
	}
	if in.Flags != nil {
		in, out := &in.Flags, &out.Flags
		*out = new(float64)
		**out = **in
	}
	if in.Flagsnaptr != nil {
		in, out := &in.Flagsnaptr, &out.Flagsnaptr
		*out = new(string)
		**out = **in
	}
	if in.Hardware != nil {
		in, out := &in.Hardware, &out.Hardware
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Inception != nil {
		in, out := &in.Inception, &out.Inception
		*out = new(string)
		**out = **in
	}
	if in.Iterations != nil {
		in, out := &in.Iterations, &out.Iterations
		*out = new(float64)
		**out = **in
	}
	if in.Key != nil {
		in, out := &in.Key, &out.Key
		*out = new(string)
		**out = **in
	}
	if in.Keytag != nil {
		in, out := &in.Keytag, &out.Keytag
		*out = new(float64)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = new(float64)
		**out = **in
	}
	if in.Mailbox != nil {
		in, out := &in.Mailbox, &out.Mailbox
		*out = new(string)
		**out = **in
	}
	if in.MatchType != nil {
		in, out := &in.MatchType, &out.MatchType
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NameServer != nil {
		in, out := &in.NameServer, &out.NameServer
		*out = new(string)
		**out = **in
	}
	if in.NextHashedOwnerName != nil {
		in, out := &in.NextHashedOwnerName, &out.NextHashedOwnerName
		*out = new(string)
		**out = **in
	}
	if in.NxdomainTTL != nil {
		in, out := &in.NxdomainTTL, &out.NxdomainTTL
		*out = new(float64)
		**out = **in
	}
	if in.Order != nil {
		in, out := &in.Order, &out.Order
		*out = new(float64)
		**out = **in
	}
	if in.OriginalTTL != nil {
		in, out := &in.OriginalTTL, &out.OriginalTTL
		*out = new(float64)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.Preference != nil {
		in, out := &in.Preference, &out.Preference
		*out = new(float64)
		**out = **in
	}
	if in.Priority != nil {
		in, out := &in.Priority, &out.Priority
		*out = new(float64)
		**out = **in
	}
	if in.PriorityIncrement != nil {
		in, out := &in.PriorityIncrement, &out.PriorityIncrement
		*out = new(float64)
		**out = **in
	}
	if in.Protocol != nil {
		in, out := &in.Protocol, &out.Protocol
		*out = new(float64)
		**out = **in
	}
	if in.RecordSha != nil {
		in, out := &in.RecordSha, &out.RecordSha
		*out = new(string)
		**out = **in
	}
	if in.Recordtype != nil {
		in, out := &in.Recordtype, &out.Recordtype
		*out = new(string)
		**out = **in
	}
	if in.Refresh != nil {
		in, out := &in.Refresh, &out.Refresh
		*out = new(float64)
		**out = **in
	}
	if in.Regexp != nil {
		in, out := &in.Regexp, &out.Regexp
		*out = new(string)
		**out = **in
	}
	if in.Replacement != nil {
		in, out := &in.Replacement, &out.Replacement
		*out = new(string)
		**out = **in
	}
	if in.Retry != nil {
		in, out := &in.Retry, &out.Retry
		*out = new(float64)
		**out = **in
	}
	if in.Salt != nil {
		in, out := &in.Salt, &out.Salt
		*out = new(string)
		**out = **in
	}
	if in.Selector != nil {
		in, out := &in.Selector, &out.Selector
		*out = new(float64)
		**out = **in
	}
	if in.Serial != nil {
		in, out := &in.Serial, &out.Serial
		*out = new(float64)
		**out = **in
	}
	if in.Service != nil {
		in, out := &in.Service, &out.Service
		*out = new(string)
		**out = **in
	}
	if in.Signature != nil {
		in, out := &in.Signature, &out.Signature
		*out = new(string)
		**out = **in
	}
	if in.Signer != nil {
		in, out := &in.Signer, &out.Signer
		*out = new(string)
		**out = **in
	}
	if in.Software != nil {
		in, out := &in.Software, &out.Software
		*out = new(string)
		**out = **in
	}
	if in.Subtype != nil {
		in, out := &in.Subtype, &out.Subtype
		*out = new(float64)
		**out = **in
	}
	if in.SvcParams != nil {
		in, out := &in.SvcParams, &out.SvcParams
		*out = new(string)
		**out = **in
	}
	if in.SvcPriority != nil {
		in, out := &in.SvcPriority, &out.SvcPriority
		*out = new(float64)
		**out = **in
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(float64)
		**out = **in
	}
	if in.Target != nil {
		in, out := &in.Target, &out.Target
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TargetName != nil {
		in, out := &in.TargetName, &out.TargetName
		*out = new(string)
		**out = **in
	}
	if in.Txt != nil {
		in, out := &in.Txt, &out.Txt
		*out = new(string)
		**out = **in
	}
	if in.TypeBitmaps != nil {
		in, out := &in.TypeBitmaps, &out.TypeBitmaps
		*out = new(string)
		**out = **in
	}
	if in.TypeCovered != nil {
		in, out := &in.TypeCovered, &out.TypeCovered
		*out = new(string)
		**out = **in
	}
	if in.TypeMnemonic != nil {
		in, out := &in.TypeMnemonic, &out.TypeMnemonic
		*out = new(string)
		**out = **in
	}
	if in.TypeValue != nil {
		in, out := &in.TypeValue, &out.TypeValue
		*out = new(float64)
		**out = **in
	}
	if in.Usage != nil {
		in, out := &in.Usage, &out.Usage
		*out = new(float64)
		**out = **in
	}
	if in.Weight != nil {
		in, out := &in.Weight, &out.Weight
		*out = new(float64)
		**out = **in
	}
	if in.Zone != nil {
		in, out := &in.Zone, &out.Zone
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RecordObservation.
func (in *RecordObservation) DeepCopy() *RecordObservation {
	if in == nil {
		return nil
	}
	out := new(RecordObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RecordParameters) DeepCopyInto(out *RecordParameters) {
	*out = *in
	if in.Algorithm != nil {
		in, out := &in.Algorithm, &out.Algorithm
		*out = new(float64)
		**out = **in
	}
	if in.Certificate != nil {
		in, out := &in.Certificate, &out.Certificate
		*out = new(string)
		**out = **in
	}
	if in.Digest != nil {
		in, out := &in.Digest, &out.Digest
		*out = new(string)
		**out = **in
	}
	if in.DigestType != nil {
		in, out := &in.DigestType, &out.DigestType
		*out = new(float64)
		**out = **in
	}
	if in.EmailAddress != nil {
		in, out := &in.EmailAddress, &out.EmailAddress
		*out = new(string)
		**out = **in
	}
	if in.Expiration != nil {
		in, out := &in.Expiration, &out.Expiration
		*out = new(string)
		**out = **in
	}
	if in.Expiry != nil {
		in, out := &in.Expiry, &out.Expiry
		*out = new(float64)
		**out = **in
	}
	if in.Fingerprint != nil {
		in, out := &in.Fingerprint, &out.Fingerprint
		*out = new(string)
		**out = **in
	}
	if in.FingerprintType != nil {
		in, out := &in.FingerprintType, &out.FingerprintType
		*out = new(float64)
		**out = **in
	}
	if in.Flags != nil {
		in, out := &in.Flags, &out.Flags
		*out = new(float64)
		**out = **in
	}
	if in.Flagsnaptr != nil {
		in, out := &in.Flagsnaptr, &out.Flagsnaptr
		*out = new(string)
		**out = **in
	}
	if in.Hardware != nil {
		in, out := &in.Hardware, &out.Hardware
		*out = new(string)
		**out = **in
	}
	if in.Inception != nil {
		in, out := &in.Inception, &out.Inception
		*out = new(string)
		**out = **in
	}
	if in.Iterations != nil {
		in, out := &in.Iterations, &out.Iterations
		*out = new(float64)
		**out = **in
	}
	if in.Key != nil {
		in, out := &in.Key, &out.Key
		*out = new(string)
		**out = **in
	}
	if in.Keytag != nil {
		in, out := &in.Keytag, &out.Keytag
		*out = new(float64)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = new(float64)
		**out = **in
	}
	if in.Mailbox != nil {
		in, out := &in.Mailbox, &out.Mailbox
		*out = new(string)
		**out = **in
	}
	if in.MatchType != nil {
		in, out := &in.MatchType, &out.MatchType
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NameServer != nil {
		in, out := &in.NameServer, &out.NameServer
		*out = new(string)
		**out = **in
	}
	if in.NextHashedOwnerName != nil {
		in, out := &in.NextHashedOwnerName, &out.NextHashedOwnerName
		*out = new(string)
		**out = **in
	}
	if in.NxdomainTTL != nil {
		in, out := &in.NxdomainTTL, &out.NxdomainTTL
		*out = new(float64)
		**out = **in
	}
	if in.Order != nil {
		in, out := &in.Order, &out.Order
		*out = new(float64)
		**out = **in
	}
	if in.OriginalTTL != nil {
		in, out := &in.OriginalTTL, &out.OriginalTTL
		*out = new(float64)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.Preference != nil {
		in, out := &in.Preference, &out.Preference
		*out = new(float64)
		**out = **in
	}
	if in.Priority != nil {
		in, out := &in.Priority, &out.Priority
		*out = new(float64)
		**out = **in
	}
	if in.PriorityIncrement != nil {
		in, out := &in.PriorityIncrement, &out.PriorityIncrement
		*out = new(float64)
		**out = **in
	}
	if in.Protocol != nil {
		in, out := &in.Protocol, &out.Protocol
		*out = new(float64)
		**out = **in
	}
	if in.Recordtype != nil {
		in, out := &in.Recordtype, &out.Recordtype
		*out = new(string)
		**out = **in
	}
	if in.Refresh != nil {
		in, out := &in.Refresh, &out.Refresh
		*out = new(float64)
		**out = **in
	}
	if in.Regexp != nil {
		in, out := &in.Regexp, &out.Regexp
		*out = new(string)
		**out = **in
	}
	if in.Replacement != nil {
		in, out := &in.Replacement, &out.Replacement
		*out = new(string)
		**out = **in
	}
	if in.Retry != nil {
		in, out := &in.Retry, &out.Retry
		*out = new(float64)
		**out = **in
	}
	if in.Salt != nil {
		in, out := &in.Salt, &out.Salt
		*out = new(string)
		**out = **in
	}
	if in.Selector != nil {
		in, out := &in.Selector, &out.Selector
		*out = new(float64)
		**out = **in
	}
	if in.Service != nil {
		in, out := &in.Service, &out.Service
		*out = new(string)
		**out = **in
	}
	if in.Signature != nil {
		in, out := &in.Signature, &out.Signature
		*out = new(string)
		**out = **in
	}
	if in.Signer != nil {
		in, out := &in.Signer, &out.Signer
		*out = new(string)
		**out = **in
	}
	if in.Software != nil {
		in, out := &in.Software, &out.Software
		*out = new(string)
		**out = **in
	}
	if in.Subtype != nil {
		in, out := &in.Subtype, &out.Subtype
		*out = new(float64)
		**out = **in
	}
	if in.SvcParams != nil {
		in, out := &in.SvcParams, &out.SvcParams
		*out = new(string)
		**out = **in
	}
	if in.SvcPriority != nil {
		in, out := &in.SvcPriority, &out.SvcPriority
		*out = new(float64)
		**out = **in
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(float64)
		**out = **in
	}
	if in.Target != nil {
		in, out := &in.Target, &out.Target
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TargetName != nil {
		in, out := &in.TargetName, &out.TargetName
		*out = new(string)
		**out = **in
	}
	if in.Txt != nil {
		in, out := &in.Txt, &out.Txt
		*out = new(string)
		**out = **in
	}
	if in.TypeBitmaps != nil {
		in, out := &in.TypeBitmaps, &out.TypeBitmaps
		*out = new(string)
		**out = **in
	}
	if in.TypeCovered != nil {
		in, out := &in.TypeCovered, &out.TypeCovered
		*out = new(string)
		**out = **in
	}
	if in.TypeMnemonic != nil {
		in, out := &in.TypeMnemonic, &out.TypeMnemonic
		*out = new(string)
		**out = **in
	}
	if in.TypeValue != nil {
		in, out := &in.TypeValue, &out.TypeValue
		*out = new(float64)
		**out = **in
	}
	if in.Usage != nil {
		in, out := &in.Usage, &out.Usage
		*out = new(float64)
		**out = **in
	}
	if in.Weight != nil {
		in, out := &in.Weight, &out.Weight
		*out = new(float64)
		**out = **in
	}
	if in.Zone != nil {
		in, out := &in.Zone, &out.Zone
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RecordParameters.
func (in *RecordParameters) DeepCopy() *RecordParameters {
	if in == nil {
		return nil
	}
	out := new(RecordParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RecordSpec) DeepCopyInto(out *RecordSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RecordSpec.
func (in *RecordSpec) DeepCopy() *RecordSpec {
	if in == nil {
		return nil
	}
	out := new(RecordSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RecordStatus) DeepCopyInto(out *RecordStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RecordStatus.
func (in *RecordStatus) DeepCopy() *RecordStatus {
	if in == nil {
		return nil
	}
	out := new(RecordStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TsigKeyInitParameters) DeepCopyInto(out *TsigKeyInitParameters) {
	*out = *in
	if in.Algorithm != nil {
		in, out := &in.Algorithm, &out.Algorithm
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Secret != nil {
		in, out := &in.Secret, &out.Secret
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TsigKeyInitParameters.
func (in *TsigKeyInitParameters) DeepCopy() *TsigKeyInitParameters {
	if in == nil {
		return nil
	}
	out := new(TsigKeyInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TsigKeyObservation) DeepCopyInto(out *TsigKeyObservation) {
	*out = *in
	if in.Algorithm != nil {
		in, out := &in.Algorithm, &out.Algorithm
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Secret != nil {
		in, out := &in.Secret, &out.Secret
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TsigKeyObservation.
func (in *TsigKeyObservation) DeepCopy() *TsigKeyObservation {
	if in == nil {
		return nil
	}
	out := new(TsigKeyObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TsigKeyParameters) DeepCopyInto(out *TsigKeyParameters) {
	*out = *in
	if in.Algorithm != nil {
		in, out := &in.Algorithm, &out.Algorithm
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Secret != nil {
		in, out := &in.Secret, &out.Secret
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TsigKeyParameters.
func (in *TsigKeyParameters) DeepCopy() *TsigKeyParameters {
	if in == nil {
		return nil
	}
	out := new(TsigKeyParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Zone) DeepCopyInto(out *Zone) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Zone.
func (in *Zone) DeepCopy() *Zone {
	if in == nil {
		return nil
	}
	out := new(Zone)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Zone) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ZoneInitParameters) DeepCopyInto(out *ZoneInitParameters) {
	*out = *in
	if in.Comment != nil {
		in, out := &in.Comment, &out.Comment
		*out = new(string)
		**out = **in
	}
	if in.Contract != nil {
		in, out := &in.Contract, &out.Contract
		*out = new(string)
		**out = **in
	}
	if in.EndCustomerID != nil {
		in, out := &in.EndCustomerID, &out.EndCustomerID
		*out = new(string)
		**out = **in
	}
	if in.Group != nil {
		in, out := &in.Group, &out.Group
		*out = new(string)
		**out = **in
	}
	if in.Masters != nil {
		in, out := &in.Masters, &out.Masters
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.OutboundZoneTransfer != nil {
		in, out := &in.OutboundZoneTransfer, &out.OutboundZoneTransfer
		*out = make([]OutboundZoneTransferInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SignAndServe != nil {
		in, out := &in.SignAndServe, &out.SignAndServe
		*out = new(bool)
		**out = **in
	}
	if in.SignAndServeAlgorithm != nil {
		in, out := &in.SignAndServeAlgorithm, &out.SignAndServeAlgorithm
		*out = new(string)
		**out = **in
	}
	if in.Target != nil {
		in, out := &in.Target, &out.Target
		*out = new(string)
		**out = **in
	}
	if in.TsigKey != nil {
		in, out := &in.TsigKey, &out.TsigKey
		*out = make([]ZoneTsigKeyInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.Zone != nil {
		in, out := &in.Zone, &out.Zone
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ZoneInitParameters.
func (in *ZoneInitParameters) DeepCopy() *ZoneInitParameters {
	if in == nil {
		return nil
	}
	out := new(ZoneInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ZoneList) DeepCopyInto(out *ZoneList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Zone, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ZoneList.
func (in *ZoneList) DeepCopy() *ZoneList {
	if in == nil {
		return nil
	}
	out := new(ZoneList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ZoneList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ZoneObservation) DeepCopyInto(out *ZoneObservation) {
	*out = *in
	if in.ActivationState != nil {
		in, out := &in.ActivationState, &out.ActivationState
		*out = new(string)
		**out = **in
	}
	if in.AliasCount != nil {
		in, out := &in.AliasCount, &out.AliasCount
		*out = new(float64)
		**out = **in
	}
	if in.Comment != nil {
		in, out := &in.Comment, &out.Comment
		*out = new(string)
		**out = **in
	}
	if in.Contract != nil {
		in, out := &in.Contract, &out.Contract
		*out = new(string)
		**out = **in
	}
	if in.EndCustomerID != nil {
		in, out := &in.EndCustomerID, &out.EndCustomerID
		*out = new(string)
		**out = **in
	}
	if in.Group != nil {
		in, out := &in.Group, &out.Group
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Masters != nil {
		in, out := &in.Masters, &out.Masters
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.OutboundZoneTransfer != nil {
		in, out := &in.OutboundZoneTransfer, &out.OutboundZoneTransfer
		*out = make([]OutboundZoneTransferObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SignAndServe != nil {
		in, out := &in.SignAndServe, &out.SignAndServe
		*out = new(bool)
		**out = **in
	}
	if in.SignAndServeAlgorithm != nil {
		in, out := &in.SignAndServeAlgorithm, &out.SignAndServeAlgorithm
		*out = new(string)
		**out = **in
	}
	if in.Target != nil {
		in, out := &in.Target, &out.Target
		*out = new(string)
		**out = **in
	}
	if in.TsigKey != nil {
		in, out := &in.TsigKey, &out.TsigKey
		*out = make([]ZoneTsigKeyObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.VersionID != nil {
		in, out := &in.VersionID, &out.VersionID
		*out = new(string)
		**out = **in
	}
	if in.Zone != nil {
		in, out := &in.Zone, &out.Zone
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ZoneObservation.
func (in *ZoneObservation) DeepCopy() *ZoneObservation {
	if in == nil {
		return nil
	}
	out := new(ZoneObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ZoneParameters) DeepCopyInto(out *ZoneParameters) {
	*out = *in
	if in.Comment != nil {
		in, out := &in.Comment, &out.Comment
		*out = new(string)
		**out = **in
	}
	if in.Contract != nil {
		in, out := &in.Contract, &out.Contract
		*out = new(string)
		**out = **in
	}
	if in.EndCustomerID != nil {
		in, out := &in.EndCustomerID, &out.EndCustomerID
		*out = new(string)
		**out = **in
	}
	if in.Group != nil {
		in, out := &in.Group, &out.Group
		*out = new(string)
		**out = **in
	}
	if in.Masters != nil {
		in, out := &in.Masters, &out.Masters
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.OutboundZoneTransfer != nil {
		in, out := &in.OutboundZoneTransfer, &out.OutboundZoneTransfer
		*out = make([]OutboundZoneTransferParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SignAndServe != nil {
		in, out := &in.SignAndServe, &out.SignAndServe
		*out = new(bool)
		**out = **in
	}
	if in.SignAndServeAlgorithm != nil {
		in, out := &in.SignAndServeAlgorithm, &out.SignAndServeAlgorithm
		*out = new(string)
		**out = **in
	}
	if in.Target != nil {
		in, out := &in.Target, &out.Target
		*out = new(string)
		**out = **in
	}
	if in.TsigKey != nil {
		in, out := &in.TsigKey, &out.TsigKey
		*out = make([]ZoneTsigKeyParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.Zone != nil {
		in, out := &in.Zone, &out.Zone
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ZoneParameters.
func (in *ZoneParameters) DeepCopy() *ZoneParameters {
	if in == nil {
		return nil
	}
	out := new(ZoneParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ZoneSpec) DeepCopyInto(out *ZoneSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ZoneSpec.
func (in *ZoneSpec) DeepCopy() *ZoneSpec {
	if in == nil {
		return nil
	}
	out := new(ZoneSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ZoneStatus) DeepCopyInto(out *ZoneStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ZoneStatus.
func (in *ZoneStatus) DeepCopy() *ZoneStatus {
	if in == nil {
		return nil
	}
	out := new(ZoneStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ZoneTsigKeyInitParameters) DeepCopyInto(out *ZoneTsigKeyInitParameters) {
	*out = *in
	if in.Algorithm != nil {
		in, out := &in.Algorithm, &out.Algorithm
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Secret != nil {
		in, out := &in.Secret, &out.Secret
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ZoneTsigKeyInitParameters.
func (in *ZoneTsigKeyInitParameters) DeepCopy() *ZoneTsigKeyInitParameters {
	if in == nil {
		return nil
	}
	out := new(ZoneTsigKeyInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ZoneTsigKeyObservation) DeepCopyInto(out *ZoneTsigKeyObservation) {
	*out = *in
	if in.Algorithm != nil {
		in, out := &in.Algorithm, &out.Algorithm
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Secret != nil {
		in, out := &in.Secret, &out.Secret
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ZoneTsigKeyObservation.
func (in *ZoneTsigKeyObservation) DeepCopy() *ZoneTsigKeyObservation {
	if in == nil {
		return nil
	}
	out := new(ZoneTsigKeyObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ZoneTsigKeyParameters) DeepCopyInto(out *ZoneTsigKeyParameters) {
	*out = *in
	if in.Algorithm != nil {
		in, out := &in.Algorithm, &out.Algorithm
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Secret != nil {
		in, out := &in.Secret, &out.Secret
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ZoneTsigKeyParameters.
func (in *ZoneTsigKeyParameters) DeepCopy() *ZoneTsigKeyParameters {
	if in == nil {
		return nil
	}
	out := new(ZoneTsigKeyParameters)
	in.DeepCopyInto(out)
	return out
}
